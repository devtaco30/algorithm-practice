/**
 * 당신은 계단을 오르고 있습니다. 계단을 모두 올라가는데는 n칸이 필요합니다.
 * 매번 당신은 1칸 혹은 2칸의 계단을 오를 수 있습니다. 이 때 계단을 오를 수 있는 방법에는 몇 가지가 있을까요?
 * 
 * 예제 1:
 *   입력: n = 2
 *   출력: 2
 *   설명: 2칸의 계단을 올라가는데는 2가지 방법이 있습니다.
 *     1칸 + 1칸
 *     2칸
 * 
 * 예제 2:
 *   입력: n = 3
 *   출력: 3
 *   설명: 3칸의 계단을 올라가는데는 3가지 방법이 있습니다.
 *     1칸 + 1칸 + 1칸
 *     1칸 + 2칸
 *     2칸 + 1칸
 * 
 * 예제 3:
 *   입력: n = 4
 *   출력: 5
 *   설명: 4칸의 계단을 올라가는데는 5가지 방법이 있습니다.
 *     1칸 + 1칸 + 1칸 + 1칸
 *     2칸 + 1칸 + 1칸
 *     1칸 + 2칸 + 1칸
 *     1칸 + 1칸 + 2칸
 *     2칸 + 2칸
 * 
 * 제약사항:
 *   1 <= n <= 45
 */

public class ClimbingStaris {
    public static void main(String[] args) {
        System.out.println(climbStairs(3));
    }
}


class Solution {
    public int climbStairs(int n) {

        // 피보나치 형태로 생각해보자.

        // 예를 들어  n = 5 라면
        // n-1 까지 채워서 거기서 1칸 더 올라가는 방법
        // n-2 까지 채워서 거기서 2칸을 한번에 채우는 방법이 있다.
        // n-2 인 3 은 1+1+1, 2+1, 2+1 3가지
        // n-1 인 4 는 1+1+1+1, 2+2, 1+1+2, 2+1+1, 1+2+1 5가지
        // n까지 가는 방법은 f(n-1) + f(n-2) 이다.
        
        // 다만, n 이 1~3까지는 그 방법은 n 과 같으므로 고정 n=4 부터 피보나치 형태로 생각해보자.
        // 그럼 결국 n 까지 가는 방법은 f(n-1) + f(n-2) 이다.

        if ((n == 1) || (n == 2)) { return n; }
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
